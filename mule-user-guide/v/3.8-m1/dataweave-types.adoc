= DataWeave Types
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping


The link:/mule-user-guide/v/3.8-m1/dataweave[DataWeave] language functions essentially as a template engine that describes an output structure through the use of elements that may be of various different types. This document covers the different types of objects you can use to construct your output.


== Object

*Type* => ':object'

Objects are represented as a collection of key:value pairs.

. Object: { 'Key' : Value }
. Key : 'Qualified Name' @('Qualified Name'= Value,...)
. Qualified Name: 'namespace prefix#name' where the 'namespace prefix#' part is optional
. Name: String that represents the name.

[TIP]
Strings must be double quoted to be recognized as strings.


=== Special Types of Objects

==== Single Value Objects

If an Object has only one key:value pair, the enclosing curly brackets { } are not required:

.Example

[source,DataWeave,linenums]
---------------------------------------------------------
%dw 1.0
%output application/xml
---
name: "Annie"
---------------------------------------------------------

==== Conditional Elements

Objects can define conditional key:value pairs based on a conditional expression.

[source,DataWeave,linenums]
---------------------------------------------------------
%dw 1.0
%output application/xml
---
file: {
  name: "transform",
  (extension: "zip") when payload.fileSystem?
}
---------------------------------------------------------

This example outputs an additional field called "extension" only when the fileSystem property is present in payload (this field may contain any value, not just "true").

[source,xml,linenums]
--------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<file>
  <name>transform</name>
  <extension>zip</extension>
</file>
--------------------------------------------------------

If absent:

[source,xml,linenums]
--------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<file>
  <name>transform</name>
</file>
--------------------------------------------------------

==== Dynamic Elements

Dynamic elements allow you to add the result of an expression as key:value pairs of an object.

.Transform
[source,DataWeave,linenums]
--------------------------------------------------------
%dw 1.0
%output application/json
---
{
  a: "a",
  (["b","c","d"] map {'$': $})
}
--------------------------------------------------------

.Output
[source,json,linenums]
--------------------------------------------------------
{
  "a": "a",
  "b": "b",
  "c": "c",
  "d": "d"
}
--------------------------------------------------------

== String

*Type* => ':string'

A string can be defined by the use of double quotes or single quotes.

[source,DataWeave, linenums]
--------------------------------------------------------
{
  doubleQuoted: "Hello",
  singleQuoted: 'Hello',
}
--------------------------------------------------------

=== String interpolation

String interpolation allows you to embed variables or expressions directly in a string.

.Transform
[source,DataWeave, linenums]
--------------------------------------------------------
%dw 1.0
%output application/json
%var name = "Shoki"
---
{
    Greeting: "Hi, my name is $name",
    Sum: "1 + 1 = $(1 + 1)"
}
--------------------------------------------------------

.Output
[source,json,linenums]
--------------------------------------------------------
{
  "Greeting": "Hi, my name is Shoki",
  "Sum": "1 + 1 = 2"
}
--------------------------------------------------------

=== Selectors

==== Index selector

Selects the character at a given position using "[]".

. If the index is bigger or equals to 0, it starts counting from the beginning.
. If the index is negative, it starts counting from the end.

.Transform
[source,DataWeave, linenums]
--------------------------------------------------------
%dw 1.0
%output application/json
---
{
  name: "Emiliano"[0]
}
--------------------------------------------------------

.Output
[source,json,linenums]
--------------------------------------------------------
{
  "name": "E"
}
--------------------------------------------------------

== Number

*Type* => ':number'

There is only one number type that supports both floating point and integer numbers.
There is no loss of precision in any operation, the engine always stores the data in the most performant way that doesn't compromise precision.

== Boolean

*Type* => ':boolean'

A boolean is defined by the keywords 'true' and 'false'.

== Dates

Dates in DataWeave follow the link:https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html[ISO-8601 standard] and are defined between '|' characters.

The date system supports:

* DateTime
* Local DateTime
* Time
* Local Time
* Period
* TimeZone
* Date


=== Date

*Type* => ':date'

Represented as 'Year'-'Month'-'Date'

The type *Date* has no time component at all (not even midnight).


.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
c: |2003-10-01|
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "c": "2003-10-01"
}
-----------------------------------------------------------------


=== Time

*Type* => ':time'

Represented as 'Hour':'Minutes':'Seconds'.'Milliseconds'

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
c: |23:59:56|
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "c": "23:59:56"
}
-----------------------------------------------------------------

=== TimeZone

*Type* => ':timeZone'

Timezones must include a + or a - to be defined as such. |03:00| is a time, |+03:00| is a timezone.


.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
c: |-08:00|
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "c": "-08:00"
}
-----------------------------------------------------------------

=== DateTime

*Type* => ':datetime'

Date time is the conjunction of 'Date' + 'Time' + 'TimeZone'.

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
a: |2003-10-01T23:57:59-03:00|
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "a": "2003-10-01T23:57:59-03:00"
}
-----------------------------------------------------------------

=== Local Date Time

*Type* => ':localdatetime'

Date time is the conjunction of 'Date' + 'Time'. Local timezone to use.

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
a: |2003-10-01T23:57:59|
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "a": "2003-10-01T23:57:59"
}
-----------------------------------------------------------------

=== Period

*Type* => ':period'

Specifies a period of time. Examples |PT9M| => 9 minutes , |P1Y| => 1 Year

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 1.0
%output application/json
---
a: |23:59:56| + |PT9M|
----------------------------------------------------------------

.Output
[source,json,linenums]
----------------------------------------------------------------
{
  "a": "00:08:56"
}
----------------------------------------------------------------


=== Accessors

In order to access the different parts of the date, special selectors must be used.

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------
%dw 1.0
%output application/json
---
{
  day: |2003-10-01T23:57:59Z|.day,
  month: |2003-10-01T23:57:59Z|.month,
  year: |2003-10-01T23:57:59Z|.year,
  hour: |2003-10-01T23:57:59Z|.hour,
  minutes: |2003-10-01T23:57:59Z|.minutes,
  seconds: |2003-10-01T23:57:59Z|.seconds,
  offsetSeconds: |2003-10-01T23:57:59-03:00|.offsetSeconds,
  nanoseconds: |23:57:59.700|.nanoseconds,
  milliseconds: |23:57:59.700|.milliseconds,
  dayOfWeek: |2003-10-01T23:57:59Z|.dayOfWeek,
  dayOfYear: |2003-10-01T23:57:59Z|.dayOfYear
}
-----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "day": 1,
  "month": 10,
  "year": 2003,
  "hour": 23,
  "minutes": 57,
  "seconds": 59,
  "offsetSeconds": -10800,
  "nanoseconds": 700000000,
  "milliseconds": 700,
  "dayOfWeek": 3,
  "dayOfYear": 274
}
-----------------------------------------------------------------

=== Changing the Format of a Date

You can specify a date to be in any format you prefer through using *as* in the following way:

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 1.0
%output application/json
---
formatedDate: |2003-10-01T23:57:59| as :string {format: "YYYY-MM-dd"}
----------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "formatedDate": "2003-10-01"
}
-----------------------------------------------------------------

If you are doing multiple similar conversions in your transform, you might want to define a custom type as a directive in the header and set each date as being of that type.

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------
%dw 1.0
%output application/json
%type mydate = :string { format: "YYYY/MM/dd" }
---
{
  formatedDate1: |2003-10-01T23:57:59| as :mydate,
  formatedDate2: |2015-07-06T08:53:15| as :mydate
}
----------------------------------------------------------------


.Output
[source,json,linenums]
-----------------------------------------------------------------
{
  "formatedDate1": "2003/10/01",
  "formatedDate2": "2015/07/06"
}
-----------------------------------------------------------------

== Regular Expressions

*Type* => ':regex'

Regular Expressions are defined between /. For example /(\d+)/ for represents multiple numerical digits from 0-9.
These may be used as arguments in certain operations that act upon strings, like Matches or Replace, or on operations that act upon objects and arrays, such as filters.


== Custom Types

You can define your own custom types in the header of your transform, then in the body you can define an element as being of that type.

To do so, the directive must be structured as following: `%type name = java definition`

For example:

[source,DataWeave,linenums]
----
%dw 1.0
%type currency = :number { format: "##"}
%type user = :object { class: “my.company.User”}
----

[TIP]
====
Usually it's a good idea to extend an existing type rather than creating one from scratch.

For example, above `:string` defines `currency` as extending the string type.
====

To then assign an element as being of the custom type you defined, use the operation `as :type` after defining a field:

[source,DataWeave,linenums]
----
%dw 1.0
%type currency = :number { format: "##"}
%type user = :object { class: “my.company.User”}
---
customer:payload.user as :user
----

=== Defining Types as a Hint for Developers

In Anypoint Studio, it's easy to view metadata that describes the input and output data of every building block you're using. When defining a custom type for a particular input or output of your transform, this is represented in the DataWeave transformer's metadata.
Exposing metadata helps you understand what it is you're integrating to in order to build up the rest of a system, as it lets you know what you need to provide and what you can expect in advance.

==== Java

===== Class

Java developers use the 'class' metadata key as hint for what class needs to be created and sent in.
If this is not explicitly defined, DataWeave tries to infer from the context or it assigns it the default values:


 * java.util.HashMap for *objects*
 * java.util.ArrayList for *lists*

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------------
%dw 1.0
%type user = :object { class: "com.anypoint.df.pojo.User"}
%output application/xml
---
{
  name : "Mariano",
  age : 31
} as :user

-----------------------------------------------------------------------

The above code defines your type as an instance of 'com.anypoint.df.pojo.User'.

==== Xml

===== CDATA

Xml specifies a new type called *:cdata* that inherits from *:string*. Using this type outputs a CDATA structure.

.Transform
[source,DataWeave, linenums]
----------------------------------------------------------------------
%dw 1.0
%output application/xml
---
{
  users:
  {
    user : "Mariano" as :cdata,
    age : 31 as :cdata
  }
}
----------------------------------------------------------------------

.Output
[source,xml,linenums]
----------------------------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<users>
  <user><![CDATA[Mariano]]></user>
  <age><![CDATA[31]]></age>
</users>
----------------------------------------------------------------------


=== Defining Types For Type Coercion


==== Format

The metadata 'format' key is used for formatting numbers and dates.

.Input
[source,xml,linenums]
-----------------------------------------------------------------------
<items>
    <item>
        <price>22.30</price>
    </item>
    <item>
        <price>20.31</price>
    </item>
</items>
-----------------------------------------------------------------------

.Transform
[source,DataWeave, linenums]
-----------------------------------------------------------------------
%dw 1.0
%output application/json
%type currency = :number { format: "##"}
---
books: payload.items.*item map
    book:
        price: $.price as :currency
-----------------------------------------------------------------------

.Output
[source,json,linenums]
-----------------------------------------------------------------------
{
  "books": [
    {
      "book": {
        "price": 22.30
      }
    },
    {
      "book": {
        "price": 20.31
      }
    }
  ]
}
-----------------------------------------------------------------------

In Anypoint Studio, you can define several more values, like separators, quote characters and escape characters. See link:/mule-user-guide/v/3.8-m1/using-dataweave-in-studio#configuring-the-csv-reader[Using DataWeave in Studio].

== Next Steps

* For a high level overview about the language, see link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction[DataWeave Language Introduction]
* For a reference about all of the operators that are available for using, see link:/mule-user-guide/v/3.8-m1/dataweave-operators[DataWeave Operators]
* For details on how to create and use your own functions, see link:/mule-user-guide/v/3.8-m1/dataweave-functions-and-lambdas[DataWeave Functions and Lambdas]
* View complete example projects that use DataWeave in the link:https://www.mulesoft.com/exchange#!/?filters=DataWeave&sortBy=rank[Anypoint Exchange]


== See Also


* link:/mule-user-guide/v/3.8-m1/using-dataweave-in-studio[Using DataWeave in Studio]
* link:/mule-user-guide/v/3.8-m1/dataweave-examples[DataWeave Examples]
* link:/mule-user-guide/v/3.8-m1/dataweave-tutorial[DataWeave Tutorial]
* link:https://www.mulesoft.com/platform/studio[Anypoint Studio]
* link:http://forums.mulesoft.com[MuleSoft's Forums]
* link:https://www.mulesoft.com/support-and-services/mule-esb-support-license-subscription[MuleSoft Support]
* mailto:support@mulesoft.com[Contact MuleSoft]
