== DataWeave Functions and Lambdas
:keywords: studio, anypoint, esb, transform, transformer, format, aggregate, rename, split, filter convert, xml, json, csv, pojo, java object, metadata, dataweave, data weave, datamapper, dwl, dfl, dw, output structure, input structure, map, mapping

image:dw-logo.png[dw]

In link:/mule-user-guide/v/3.8-m1/dataweave[DataWeave], if you want to carry out a complex operation that is not covered by any of the existing link:/mule-user-guide/v/3.8-m1/dataweave-operators[Operators], you can create a function or a lambda.

Functions and Lambdas can be defined anywhere in the DataWeave code, and even be treated as link:/mule-user-guide/v/3.8-m1/dataweave-types#object[objects], you can then pass them as arguments for other functions. They are defined through `%var` (as with variables) using a lambda, or through `%function`.

They can be defined in the link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction#the-dataweave-header[the DataWeave header], as link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction#define-function-directive[function directives], or anywhere in the link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction#the-dataweave-body[the DataWeave body].


== Lambdas

Lambdas can be used inside operators such as map, mapObject, etc. or they can be assigned to a variable.
When using lambdas within the body of a DataWeave file in conjunction to an operator such as link:/mule-user-guide/v/3.8-m1/dataweave-operators#map[map], its attributes can either be explicitly named or left anonymous, in which case they can be referenced as $, $$, etc.

=== Assign to a var

You can define a lambda as a variable with a link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction#define-constant-directive[constant directive] through '%var'

.Transport
[source,DataWeave, linenums]
----
%dw 1.0
%output application/json
%var toUser = (user) -> {firstName: user.givenName, lastName: user.sn}
---
{
  "user" : toUser({ givenName : "Annie", sn : "Point" })
}
----

.Output
[source, json,linenums]
----
{
  "user": {
    "firstName": "Annie",
    "lastName": "Point"
  }
}
----

=== Named attributes with an Operator

This example uses a lambda with an attribute that's explicitly named as 'name'.

.Input
[source,DataWeave, linenums]
---------------------------------------------------------------------
%dw 1.0
%output application/json
---
users: ["john", "peter", "matt"] map ((name) ->  upper name)
---------------------------------------------------------------------

.Transform
[source,json,linenums]
---------------------------------------------------------------------
{
  "users": ["JOHN","PETER","MATT"]
}
---------------------------------------------------------------------

=== Anonymous attributes with an Operator

This example uses a lambda with an attribute that's not explicitly named, and so is referred to by default as '$'.

.Transform
[source,DataWeave, linenums]
---------------------------------------------------------------------
%dw 1.0
%output application/json
---
users: ["john", "peter", "matt"] map  upper $
---------------------------------------------------------------------

.Output
[source,json,linenums]
---------------------------------------------------------------------
{
  "users": ["JOHN","PETER","MATT"]
}
---------------------------------------------------------------------


== Functions

You can declare functions in the Header and these can be invoked at any point in the Body, you can also declare functions anywhere in the body. You refer to them using the form *function-name()* passing an expression in between the parenthesis for each necessary argument. Each expression between the parenthesis is evaluated and the result is passed as an argument used in the execution of the function body.

.Transform
[source,DataWeave, linenums]
----
%dw 1.0
%output application/json
%function toUser(user){firstName: user.givenName, lastName: user.sn}
---
{
  "user" : toUser({ givenName : "Annie", sn : "Point" })
}
----

.Output
[source, json,linenums]
----
{
  "user": {
    "firstName": "Annie",
    "lastName": "Point"
  }
}
----

=== Existing Functions

==== Expressions that Call External Flows

From a DataWeave transform, you can trigger the calling of a different flow in your Mule application, and whatever the flow returns is what the expression returns.

You can do this through the following expression:

`lookup(“flowName”,$)`

Which takes two parameters:

* The name of the flow that must be called
* The payload to send to this flow, as a map

.Transform
[source,DataWeave, linenums]
----
%dw 1.0
%output application/json
---
{
  a: lookup("mySecondFlow",{b:"Hello"})
}
----

.Mule Flow
[source, xml,linenums]
----
<flow name="mySecondFlow">
    <set-payload doc:name="Set Payload" value="#[payload.b + ' world!' ]"/>
</flow>
----

.Output
[source, json,linenums]
----
{
  "a": "Hello world!"
}
----



== Calling Global MEL Functions from DataWeave Code

If you define a global link:/mule-user-guide/v/3.8-m1/mule-expression-language-mel[Mule Expression Language] (MEL) function in your Mule project, you can then invoke it anywhere in your DataWeave code, without need for any special syntax.

To create one such global function, you must edit your Mule project's XML file and enclose any functions that you wish to define in the following set of tags, which must be placed in the global elements section, before any of the flows are defined.

[source, xml, linenums]
----
<configuration doc:name="Configuration">
     <expression-language>
         <global-functions>

         </global-functions>
     </expression-language>
 </configuration>
----


In this space you can use any MEL expression to define custom functions, for example:

[source, xml, linenums]
----
<configuration doc:name="Configuration">
     <expression-language>
         <global-functions>
             def newUser() {
                 return ["name" : "mariano"]
             }
             def upperName(user) {
                 return user.name.toUpperCase()
             }
         </global-functions>
     </expression-language>
 </configuration>
----


With that in place, in the DataWeave code of your Transform Message element you can just refer to these functions. Note that the inputs and outputs of these functions can even be objects and arrays.

[source, ruby, linenums]
----
%dw 1.0
%output application/json
---
{
  "foo" :  newUser(),
  "bar":  upperName(newUser())
}
----


Even with these external functions in place, you should be able to preview the output of this transform, updated in real time as you edit it.



== Next Steps

* For a high level overview about the language, see link:/mule-user-guide/v/3.8-m1/dataweave-language-introduction[DataWeave Language Introduction]
* For a reference about all of the already existing operators that are available for executing from scratch, see link:/mule-user-guide/v/3.8-m1/dataweave-operators[DataWeave Operators]
* For a listing and details about all of the types you can use, see link:/mule-user-guide/v/3.8-m1/dataweave-types[DataWeave Types]
* View complete example projects that use DataWeave in the link:https://www.mulesoft.com/exchange#!/?filters=DataWeave&sortBy=rank[Anypoint Exchange]

== See Also

* link:/mule-user-guide/v/3.8-m1/using-dataweave-in-studio[Using DataWeave in Studio]
* link:/mule-user-guide/v/3.8-m1/dataweave-examples[DataWeave Examples]
* link:/mule-user-guide/v/3.8-m1/dataweave-tutorial[DataWeave Tutorial]
* link:/mule-user-guide/v/3.8-m1/mel-dataweave-functions[MEL DataWeave Functions]
* link:http://forums.mulesoft.com[MuleSoft's Forums]
* link:https://www.mulesoft.com/support-and-services/mule-esb-support-license-subscription[MuleSoft Support]
* mailto:support@mulesoft.com[Contact MuleSoft]
